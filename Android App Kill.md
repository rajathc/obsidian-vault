Thanks! I’ll put together a summary of best practices to prevent Android apps that use Bluetooth from getting killed in the background, and then dig into technical recommendations to improve stability across devices and Android versions.

# Preventing Android App Kills in the Background (Bluetooth Communication)

## 1. Overview: Best Practices for Background Survival

Keeping a Bluetooth-connected app alive in the background requires working _with_ Android’s power management, not against it. Key best practices include using a **Foreground Service** (with a persistent notification) for any continuous Bluetooth communication, carefully handling **Doze mode** and **App Standby** constraints, and leveraging system APIs like **WorkManager** or **JobScheduler** for deferred tasks. It’s also important to request **battery optimization exemptions** (whitelisting) when absolutely needed (e.g. for critical Bluetooth connectivity) and to configure your app’s manifest and code for robust process restart. Additionally, be aware of **OEM-specific quirks** (Samsung, Xiaomi, OnePlus, etc.) that can kill background apps despite following Android guidelines, and guide users to disable those aggressive optimizations. In summary, combine a persistent foreground service, proper scheduling for background work, and user-enabled exceptions to keep Bluetooth communication stable in the background.

## 2. Use Foreground Services for Persistent Bluetooth Connections

For real-time or long-term Bluetooth communication, a foreground service is the most reliable approach. A foreground service runs with higher priority and must show a notification, which signals to the system (and user) that your app is doing important work. This greatly reduces the chance of the app being killed for background activity limits ([service - What is the best way to maintain a Bluetooth connection after app is killed in Android? - Stack Overflow](https://stackoverflow.com/questions/43267520/what-is-the-best-way-to-maintain-a-bluetooth-connection-after-app-is-killed-in-a#:~:text=First%20of%20all%20I%20suggest,using%20a%20foreground%20service)). In fact, on Android 8+ (Oreo and above), a foreground service is **exempt from background execution limits** ([service - What is the best way to maintain a Bluetooth connection after app is killed in Android? - Stack Overflow](https://stackoverflow.com/questions/43267520/what-is-the-best-way-to-maintain-a-bluetooth-connection-after-app-is-killed-in-a#:~:text=First%20of%20all%20I%20suggest,using%20a%20foreground%20service)), meaning the system will allow it to continue running even if the user isn’t actively using the app.

**Implementation:** In your service code, start it in the foreground as soon as possible. For example:

```java
// Starting the service (from an Activity or BroadcastReceiver):
Intent serviceIntent = new Intent(context, BluetoothService.class);
ContextCompat.startForegroundService(context, serviceIntent);  // use for API 26+

// In BluetoothService.java (which extends Service):
@Override 
public int onStartCommand(Intent intent, int flags, int startId) {
    // Create a persistent notification
    Notification notification = createServiceNotification();
    // Promote to foreground with notification
    startForeground(NOTIFICATION_ID, notification);
    
    // TODO: Initialize Bluetooth connection or scanning here
    
    // Return START_STICKY to restart if killed by system
    return START_STICKY;
}
```

In the manifest, declare the service and the required foreground service permission:

```xml
<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
...
<service 
    android:name=".BluetoothService"
    android:exported="false"
    android:foregroundServiceType="connectedDevice"  <!-- for API 29+ -->
    android:stopWithTask="false" >                   <!-- keep running even if app UI task is removed -->
</service>
```

The `foregroundServiceType="connectedDevice"` flag (available on Android 10+, API 29) is specifically intended for services managing a connected device ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=REQUEST_COMPANION_RUN_IN_BACKGROUND%20%20permission%20and%20the,with%20the%20connectedDevice%20foreground%20type)). It helps the system understand the service’s purpose (and on Android 12+ it’s required to properly categorize the service type). Using a foreground service ensures the app process stays alive **indefinitely** (until you stop the service), and if the system does kill it for resource pressure, it will try to recreate the service process due to the `START_STICKY` return (so your `onCreate()`/`onStartCommand()` will be called again) ([service - What is the best way to maintain a Bluetooth connection after app is killed in Android? - Stack Overflow](https://stackoverflow.com/questions/43267520/what-is-the-best-way-to-maintain-a-bluetooth-connection-after-app-is-killed-in-a#:~:text=First%20of%20all%20I%20suggest,using%20a%20foreground%20service)). This makes your Bluetooth connection resilient – you can reinitialize the Bluetooth Adapter and reconnect in `onCreate()` if needed.

**Persistent Notification:** Make the notification user-friendly, e.g. “Bluetooth device connected – tap to return to app.” This is required for the foreground service; without a notification, the system will not keep the service in the foreground. Keep the notification ongoing (use `Notification.FLAG_ONGOING_EVENT`) so the user knows the app is active in background.

**Auto-Reconnect:** For BLE devices, consider using `autoConnect=true` when connecting. This allows the Android Bluetooth stack to automatically reconnect dropped connections in the background. Combined with a foreground service, this means even if the user temporarily leaves the app, the connection can be maintained and recovered automatically ([android - How to Bluetooth LE background connection? - Stack Overflow](https://stackoverflow.com/questions/77595114/how-to-bluetooth-le-background-connection#:~:text=)). Monitor the `BluetoothGattCallback.onConnectionStateChange` events to handle reconnection logic or to notify the user if the device goes out of range.

## 3. Handling Doze Mode and App Standby

Modern Android devices (6.0+ and especially 10+ with **Adaptive Battery**) will enter Doze mode or App Standby to conserve power when the device or apps are idle. In **Doze mode**, the system applies strict restrictions: for example, **network access is suspended and wake locks are ignored** while in deep doze ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=The%20system%20applies%20the%20following,your%20apps%20while%20in%20Doze)). This can directly impact Bluetooth communication in background – if your app isn’t whitelisted, the CPU might not wake to process Bluetooth events, causing connection drops or delayed data.

**Effects of Doze on Bluetooth:** While Bluetooth LE advertising and GATT may still happen at the radio level, your app’s processing of incoming data or keep-alive pings could be delayed until Doze maintenance windows (which occur infrequently as Doze progresses) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=Periodically%2C%20the%20system%20exits%20Doze,lets%20apps%20access%20the%20network)) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=,Fi%20scans)). App Standby, on the other hand, can restrict an app’s background network access if the user hasn’t used it recently (this mainly affects background data sync or cloud communication). A Bluetooth app that the user actively uses (or that has an ongoing foreground service notification) will likely be considered “active,” but overnight or after long idle periods, Doze can still kick in when the device is stationary, regardless of foreground service.

**Strategies to Handle Doze:**

- **Request Doze Exemption (Whitelist):** The surest way to keep Bluetooth communications flowing during idle periods is to ask the user to exempt the app from battery optimizations. A whitelisted app is not subject to Doze restrictions (meaning it can get CPU time, network access, and wake locks as normal) ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=automatically%20released%20when%20the%20device,see%20later)) ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=,than%20some%20Google%20system%20apps)). You can check and request this at runtime:
    
    ```java
    PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
        String pkg = getPackageName();
        if (!pm.isIgnoringBatteryOptimizations(pkg)) {
            Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);
            intent.setData(Uri.parse("package:" + pkg));
            startActivity(intent);
        }
    }
    ```
    
    Remember to include `<uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />` in your manifest. When invoked, the system will show a prompt asking the user to allow your app to “run in the background” without battery optimizations. If the user **Allow**s, your app’s status will change to “Not optimized” (you can verify in system Settings > Battery Optimization) ([android - ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS does nothing - Stack Overflow](https://stackoverflow.com/questions/52617790/action-request-ignore-battery-optimizations-does-nothing#:~:text=I%20am%20using%20a%20Pixel,not%20optimized)) ([android - ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS does nothing - Stack Overflow](https://stackoverflow.com/questions/52617790/action-request-ignore-battery-optimizations-does-nothing#:~:text=%40GeordieWicks%3A%20Correct)). This makes a huge difference: for instance, a partial wake lock held by your app will _not_ be released by the system upon entering Doze if your app is whitelisted ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=automatically%20released%20when%20the%20device,see%20later)) (whereas normally Doze would drop all wake locks).
    
    **⚠️ Caution:** Google Play’s policies restrict which apps can legitimately request this exemption. It’s intended for apps that have a clear need to run continuously in the background (e.g. companion device apps, health trackers, navigation apps, etc.). Misusing this request for trivial reasons can lead to Play Store rejection ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=match%20at%20L515%20Android%20Studio%2C,through%20Google%E2%80%99s%20managed%20play%20store)). Ensure you only prompt this if it’s truly necessary for core functionality and educate the user why it’s needed. On some devices, even whitelisted apps can be affected by manufacturer custom optimizations (see device-specific section below).
    
- **Use Maintenance Windows Wisely:** If you cannot get whitelisted (or choose not to ask), design your background work to tolerate Doze’s maintenance windows. Doze will periodically wake the device for short intervals (maintenance windows) to let apps sync and communicate ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=Periodically%2C%20the%20system%20exits%20Doze,lets%20apps%20access%20the%20network)). You might ensure your app can queue any pending data and send it during these windows. For example, if your app is receiving sensor data from a BLE device regularly, cache it and batch-upload during maintenance windows (though the BLE connection itself may not survive long Doze without a whitelisted app or foreground service).
    
- **AlarmManager for Critical Wakes:** Doze defers standard alarms, but you can use `AlarmManager.setAndAllowWhileIdle()` or `setExactAndAllowWhileIdle()` to schedule critical operations during Doze ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=,Doesn%27t%20let%20%20177%20run)) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=and%20,uses)). For instance, you might set an alarm to wake your app (invoke a service or broadcast) every few hours to check on a connection or perform a keep-alive. These APIs let the alarm fire even in Doze, but they are subject to limits (at most one wake-up per 9 minutes per app in Doze) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=,Doesn%27t%20let%20%20177%20run)) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=Note%3A%20Neither%20,per%20nine%20minutes%2C%20per%20app)). Overusing this will drain battery and could trigger system throttling, so use sparingly (e.g., a lightweight ping or reconnect attempt).
    
- **Firebase Cloud Messaging (FCM):** While not directly a Bluetooth mechanism, if your app also communicates with a server, using FCM high-priority messages can wake a dozing device and let you perform short actions ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=,tasks%20don%27t%20run)). This doesn’t directly maintain a BLE connection, but it’s a technique to trigger the app (for example, to tell it to reconnect to a device or alert the user) even during Doze. (Ensure the message results in a user-visible notification, as required for high-priority FCM usage ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=))). FCM is less relevant for pure device-to-device Bluetooth comms, but it can be part of your strategy if cloud is involved.
    
- **Testing and Tuning:** Use `adb shell dumpsys deviceidle step` and related ADB commands to simulate Doze on a test device ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=To%20confirm%20that%20your%20app,with%20Doze%20and%20App%20Standby)). This lets you verify that your Bluetooth connection logic behaves as expected (e.g. the foreground service is running, or the app properly reconnects after Doze). You might find that without whitelisting, a BLE connection drops after a certain time in idle; with whitelisting, it stays stable. Adjust your approach based on these tests (perhaps prompting the user to adjust settings if needed).
    

**App Standby & Adaptive Battery:** Android’s App Standby Bucket (API 28+) will classify apps by usage frequency. If your app is rarely opened, it might be put in a “Restricted” bucket with severe limits on jobs and alarms. A Bluetooth app that a user uses daily (or that has an active notification) is likely in the “Active” or “Working Set” bucket, which is less restrictive. To avoid being classified as “idle,” encourage user interaction: the persistent notification can be interactive, or you can occasionally bring the user’s attention to the app (for example, “Tap to check device status”). On Samsung devices with **Adaptive Battery** (or their own “App power management”), ensure the user either disables that feature or marks your app as an exception (“Never sleeping apps” on Samsung). More on this below.

**Summary:** Use a **foreground service** (which keeps an ongoing notification) to greatly reduce Doze impacts – the device may still enter Doze, but the service will resume as soon as the maintenance window opens, and being foreground helps keep the app in the Active bucket. For absolutely critical background Bluetooth streaming (e.g. medical device monitoring), guide the user to **whitelist** the app from battery optimizations ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=,than%20some%20Google%20system%20apps)), as this is the only way to truly bypass Doze’s CPU/network freezes. Be mindful of the additional battery cost and platform policies before doing so.

([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby)) _Figure: Device enters Doze (green bar) when screen is off, periodically waking for maintenance windows (orange bars) during which deferred tasks and network/bluetooth communication can occur ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=Periodically%2C%20the%20system%20exits%20Doze,lets%20apps%20access%20the%20network)) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=Image%20Figure%201,network%20and%20handle%20pending%20activities))._

## 4. Using JobScheduler & WorkManager for Background Tasks

Not all background operations require your app to stay in memory continuously. For tasks that can be done periodically or with some delay (such as syncing data with a server, periodic BLE scans, or retrying a lost connection), **JobScheduler** (available from API 21+) or its Jetpack counterpart **WorkManager** are recommended. These APIs schedule work with the Android system, which can batch and defer tasks to optimize battery usage.

**JobScheduler:** You can create a `JobService` that, for example, attempts to reconnect to a Bluetooth device or checks device status at intervals. Using `JobInfo.Builder`, you might specify requirements like `.setRequiresDeviceIdle(false)` (since you likely want it even when not idle) or `.setPeriodic(intervalMillis)` for periodic jobs. The system will invoke your JobService at appropriate times. This is better than manually using `Handler.postDelayed` loops, as the system can adjust timings to avoid needless wake-ups. However, note that in Doze, **JobScheduler jobs won’t run until the maintenance window** ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=system%20exits%20Doze%20shortly%20before,tasks%20don%27t%20run)) unless the app is whitelisted. So jobs are a good choice for general background work, but not for _real-time_ keep-alive during deep idle.

**WorkManager:** WorkManager is a higher-level API that chooses the appropriate scheduler (JobScheduler on new devices, or Alarm + Broadcast on older ones) to execute background work. It’s perfect for tasks like: “Every 15 minutes, check if the Bluetooth device is still connected, and if not, attempt to reconnect,” or “Upload collected data once an hour when on Wi-Fi.” WorkManager ensures these tasks execute reliably even if the app exits, and can survive device reboots (if you use `setPersisted(true)` on JobScheduler or `WorkManager.enqueueUniquePeriodicWork` with `ExistingPeriodicWorkPolicy.KEEP`).

**Using WorkManager Example:**

```kotlin
val workRequest = PeriodicWorkRequestBuilder<BluetoothKeepAliveWorker>(15, TimeUnit.MINUTES)
    .setConstraints(
        Constraints.Builder()
            .setRequiresBatteryNotLow(true)
            .setRequiresDeviceIdle(false)
            .build()
    )
    .build()
WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "bt_keepalive", ExistingPeriodicWorkPolicy.REPLACE, workRequest
)
```

In the `BluetoothKeepAliveWorker` (which extends `Worker`), you would check connection health and maybe initiate a lightweight BT operation (like a BLE scan or a small data exchange) to keep the connection fresh. If the device was disconnected, you could try to reconnect. Remember, if the phone is in Doze, this work may not run until the device wakes (unless your app is whitelisted). If it’s crucial to wake at exact times, consider using `AlarmManager` as mentioned, otherwise accept that WorkManager will run the job when allowed.

**Foreground vs WorkManager:** One might consider using WorkManager to maintain a long-running BLE connection by doing work continuously, but this is not its purpose. WorkManager jobs are finite and meant to finish; you **cannot keep a Worker running indefinitely**. If you need an ongoing live connection, a service is the way. In fact, trying to use WorkManager for a continuous BLE connection will fail – WorkManager will not keep the app process alive for an interactive connection, and cannot easily listen for asynchronous BLE callbacks over a long period. As one expert succinctly put it, _WorkManager will not manage an operation meant to keep the app alive continuously; a foreground service is the correct approach for a stable long-term connection_ ([android - How to Bluetooth LE background connection? - Stack Overflow](https://stackoverflow.com/questions/77595114/how-to-bluetooth-le-background-connection#:~:text=Here%20I%20suggest%20please%20use,would%20be%20the%20great%20option)).

Instead, think of JobScheduler/WorkManager as a _compliment_ to your foreground service: for example, if your service ever dies, you might have a scheduled job as a fallback to restart it. Or use WorkManager for non-critical periodic tasks (like syncing logs) so your foreground service can focus on the real-time Bluetooth tasks.

**Summary:** Use WorkManager/JobScheduler for **deferred or periodic tasks** related to your Bluetooth functionality (scans, periodic sync, or attempting reconnection at intervals if not urgent). They respect battery optimization and system scheduling, which is good for the device health, but they are not immune to Doze (they’ll run in maintenance windows) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=system%20exits%20Doze%20shortly%20before,tasks%20don%27t%20run)). Always use a Foreground Service for the actual continuous communication, and let WorkManager handle the rest in a battery-friendly way. This hybrid approach gives you reliability without forcing the app to do everything actively in memory.

## 5. Requesting Battery Optimization Exemptions

As discussed, getting exempted from Doze/App Standby via the **battery optimization whitelist** is a powerful way to prevent background killing. However, it’s ultimately in the user’s hands (and should be used judiciously). Here’s what to consider:

- **How to Request:** Use the `ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS` intent as shown earlier to prompt the user. When the user taps “Allow,” Android will add your app to the whitelist. On stock Android, this immediately takes effect (no reboot needed) ([android - ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS does nothing - Stack Overflow](https://stackoverflow.com/questions/52617790/action-request-ignore-battery-optimizations-does-nothing#:~:text=I%20put%20your%20code%20in,No%20reboot%20required)) ([android - ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS does nothing - Stack Overflow](https://stackoverflow.com/questions/52617790/action-request-ignore-battery-optimizations-does-nothing#:~:text=I%20am%20using%20a%20Pixel,not%20optimized)) – you can confirm via `pm.isIgnoringBatteryOptimizations()` returning true. On some devices or older Android versions, the Settings UI might still show “Optimizing” until a reboot or after some delay, but the whitelisting should work under-the-hood. (A StackOverflow report noted this behavior on certain phones with Android 8.1, whereas it was fixed on Android 9+ Pixel devices ([android - ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS does nothing - Stack Overflow](https://stackoverflow.com/questions/52617790/action-request-ignore-battery-optimizations-does-nothing#:~:text=So%2C%20either%3A)).)
    
- **Effectiveness:** A whitelisted app will not be put into Doze mode. This means:
    
    - The app’s wakelocks _will be honored_ (so you could, for example, acquire a `PARTIAL_WAKE_LOCK` to keep the CPU running in the background – although with a foreground service this is usually not needed, as the service itself keeps the process active).
    - Network access and Bluetooth operations are not curtailed by Doze. If your app is continuously exchanging data with a Bluetooth device, whitelisting ensures those exchanges aren’t paused by the system ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=automatically%20released%20when%20the%20device,see%20later)) ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=,than%20some%20Google%20system%20apps)).
    - WorkManager/JobScheduler tasks from your app will not be deferred – they run as scheduled, even during device idle.
    - However, **battery usage will be higher**, and the system will warn the user that your app may drain battery faster ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=,than%20some%20Google%20system%20apps)). Be prepared for potential user concern here – you might provide in-app messaging like, “We recommend allowing this app to run without battery restrictions to maintain a stable Bluetooth connection.”
- **Google Play Policy:** Only request this if your app truly needs to run continuously. Google explicitly flags inappropriate use of `REQUEST_IGNORE_BATTERY_OPTIMIZATIONS` as a violation of Play Store policy ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=match%20at%20L515%20Android%20Studio%2C,through%20Google%E2%80%99s%20managed%20play%20store)). Acceptable use cases typically include: apps that sync data for wearable devices, health monitoring apps, navigation apps, background location trackers for safety, etc. Make sure you clearly explain to users why they should grant the exception (e.g., “This app needs to run in the background to stay connected to your device and ensure you receive real-time data/alerts.”). If your use case is marginal, consider alternatives before asking for whitelist.
    
- **Manufacturer Variations:** On many devices (Pixel, Motorola, etc.), getting whitelisted is a one-stop solution to avoid background kills. But some OEMs have their own additional battery managers. For example, on **Samsung** devices (Android 11+), users must still disable the “Put app to sleep” settings – Samsung by default will still put apps to sleep despite Android’s whitelist, unless the user turns off battery optimization in their Device Care settings ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=Android%2011)). On **OnePlus**, as mentioned, the setting can revert itself, so just being on the whitelist might not stick (users often have to lock the app in recents too ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=severe%20background%20limits%20on%20the,settings%20on%20a%20regular%20basis)) ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=App%20locking))). So while requesting the standard Android exemption is important, you may need to guide the user to further device-specific settings (next section).
    

In summary, **battery optimization exemption** is one of the most effective tools to prevent Doze-related kills and keep your Bluetooth service responsive 24/7. Use it carefully: prompt the user at an appropriate time (for example, after explaining why, or on first attempt to start the background service), and handle the case where the user denies the request (perhaps fall back to reduced functionality or periodic reconnections during maintenance windows). Always adhere to Play Store guidelines when implementing this.

## 6. Manifest and Code Configurations for Resiliency

Beyond services and scheduling, there are a number of manifest and code-level configurations that can improve your app’s survivability in the background:

- **Foreground Service Declaration:** As shown above, declare your service in the manifest with the appropriate attributes. Setting `android:stopWithTask="false"` ensures that if the user closes your app’s UI (task) or swipes it from recent apps, the service isn’t automatically stopped by the system (though on some OEMs, swiping might still stop it, see next section). Also use the `foregroundServiceType` attribute (e.g. `"connectedDevice"` for Bluetooth connections, or combine types like `"connectedDevice|location"` if your Bluetooth usage involves location data) for Android Q and above ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=REQUEST_COMPANION_RUN_IN_BACKGROUND%20%20permission%20and%20the,with%20the%20connectedDevice%20foreground%20type)).
    
- **Service Start Mode:** In your `Service.onStartCommand`, return `START_STICKY` for a continuously running service. This flags to the system that if the service is killed due to low memory, it should be restarted when resources become available, with a null Intent. This is crucial for long-running services like Bluetooth handlers. (If your service holds an active BT connection, the system tends to keep it around, but if it does die, `START_STICKY` combined with a foreground notification will attempt to resurrect it.)
    
- **Broadcast Receivers for Restart:** Use the manifest to register for certain system broadcasts that can restart your app’s components when needed:
    
    - `android.intent.action.BOOT_COMPLETED` – so that when the device reboots, your app can automatically start its service (if the user expects that, e.g. a device that should connect on boot). You’ll need the `RECEIVE_BOOT_COMPLETED` permission. In the receiver’s `onReceive`, start your `BluetoothService` (consider using `startForegroundService` on Android O+).
    - `android.intent.action.ACTION_SHUTDOWN` – to gracefully disconnect from the device when the phone is shutting down, if needed.
    - **Bluetooth events:** If applicable, listen for `BluetoothDevice.ACTION_ACL_CONNECTED` and `ACTION_ACL_DISCONNECTED` in a BroadcastReceiver. These events occur when any classic Bluetooth device connects or disconnects to the phone. If your app knows the device’s MAC or BT device ID, it can filter these Intents and use them as triggers (e.g., if your peripheral connects and your app isn’t running, an `ACL_CONNECTED` could wake a broadcast receiver, which could then start your service). **Note:** On Android 8+, most implicit broadcasts are restricted; however, Bluetooth connection broadcasts _should_ still be delivered to manifest-registered receivers (they are _explicit_ system broadcasts). Just ensure you declare the BLUETOOTH permissions and the receiver properly. This technique can help recover the connection if the system killed your app but the user toggles the device or it reconnects.
- **Companion Device API:** Starting Android Oreo (8.0), the **Companion Device Manager** API was introduced for apps to associate with companion Bluetooth/Wi-Fi devices (like smart watches, fitness trackers, etc.). If your app uses `CompanionDeviceManager` pairing, you can declare a `CompanionDeviceService` in your app along with the permission `REQUEST_COMPANION_RUN_IN_BACKGROUND` (and possibly `REQUEST_COMPANION_USE_DATA_IN_BACKGROUND` for network) ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=,the%20%20194%20foreground%20type)). Apps with a registered companion device service can have the system keep them running in the background specifically for that device communication. This is an alternative to a generic foreground service. The Android docs note that using a `CompanionDeviceService` with the appropriate permission allows an app to **stay connected indefinitely** for listening to the companion device (ideal for long-term BLE notifications streaming) ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=To%20listen%20to%20peripheral%20notifications,also%20use%20a%20foreground%20service)). If targeting newer Android versions and applicable to your device type, this API can help bypass background limits without needing the user to manually whitelist (since the user explicitly grants your app companion device privileges during pairing).
    
- **Permissions:** Ensure you have all the necessary permissions in the manifest _and_ at runtime (for dangerous ones):
    
    - Bluetooth: On Android 12+, you need `BLUETOOTH_CONNECT` for connecting/GATT, `BLUETOOTH_SCAN` for scanning (with `usesPermissionFlags="neverForLocation"` if you don’t need location info from BLE), and possibly `BLUETOOTH_ADVERTISE` if your app advertises. On older versions, `BLUETOOTH` and `BLUETOOTH_ADMIN` cover these.
    - Location: If your Bluetooth usage involves device scanning or any activity that can infer location (BLE scan results are considered location-sensitive), you need location permissions. For background use on Android 10+, that means ACCESS_FINE_LOCATION (for scans in foreground) and ACCESS_BACKGROUND_LOCATION if scans happen while the app is backgrounded. Failing to have these will cause your scans to not yield results (or for the system to stop your scans quickly), which might be mistaken for the app being “killed” when in fact it’s a permission issue. Make sure to request these permissions from the user with clear explanation.
    - Foreground service: As shown, declare `FOREGROUND_SERVICE` permission for Android Pie+.
    - Ignore battery optimizations: As covered, declare `REQUEST_IGNORE_BATTERY_OPTIMIZATIONS` if you intend to prompt for whitelist.
- **Partial Wake Locks:** If for some reason you cannot use a foreground service (or in addition to it), acquiring a `PARTIAL_WAKE_LOCK` via `PowerManager.WakeLock` can keep the CPU on while the screen is off. However, remember that in Doze, wake locks are ineffective unless the app is whitelisted ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=The%20system%20applies%20the%20following,your%20apps%20while%20in%20Doze)). Generally, if you have a foreground service, you shouldn’t need a manual wake lock most of the time – the system will already keep your process running. You might use a wake lock around brief operations (like during a critical data transfer) to ensure the device doesn’t sleep in the middle, but always release it as soon as done. Rely on the foreground service and properly structured threading (like using `BluetoothGattCallback` on its threads, etc.) to handle continuous operation.
    
- **Service in Separate Process (Optional):** In some cases, developers run the Bluetooth service in a separate process (using `android:process`: e.g., `android:process=":btservice"` in the manifest for your service). This can isolate it from your UI process. If the UI crashes or is killed, the service can in theory continue. Android will treat it as another app process (still under your app’s UID). This can be helpful if you experience crashes in one part of the app that should not bring down the BT connection. However, it increases complexity (IPC between processes if they need to communicate) and uses more memory. Use only if you have a specific need.
    
- **Error Handling & Reconnection Logic:** On the code level, implement robust error handling for the Bluetooth connection. For example, implement the `BluetoothGattCallback.onConnectionStateChange` to listen for `STATE_DISCONNECTED` and attempt reconnection after a delay (perhaps using a Handler or posting a WorkManager one-time task to reconnect). If you do this inside a foreground service, the code will run even in background. Also handle cases where the device might go out of range or turn off – in those cases, continuously keeping the service alive is futile until the device is back, so you might stop the service after a timeout of trying, to save resources, and maybe schedule a job to periodically check if the device is back in range (advertising).
    
- **Monitoring App State:** You can use `ProcessLifecycleOwner` or a simple static flag to know if your app is in the foreground or background (on Android, an app is considered in background once none of its activities are visible). If your app enters background, you might downgrade some operations (e.g., stop heavy UI-related tasks, but keep the essential BT operations running in the service). Also implement `Service.onDestroy()` and/or `onTaskRemoved()` – these can be called when the system is about to kill your service. In these, you could, for instance, schedule an `AlarmManager` to restart the service in a few seconds. **Note:** On newer Android, if the user swipes away the app (which triggers `onTaskRemoved`), the system **will** stop your foreground service as well (this is considered a user stop action for many OEMs). You might try to restart via alarm, but often the system will prevent it shortly after a user action. Some devs include a small `onTaskRemoved()` hack like:
    
    ```java
    @Override
    public void onTaskRemoved(Intent rootIntent) {
        // Restart service in 1 second
        PendingIntent restartIntent = PendingIntent.getService(
            getApplicationContext(), 1, 
            new Intent(getApplicationContext(), BluetoothService.class), 
            PendingIntent.FLAG_IMMUTABLE);
        AlarmManager alarm = (AlarmManager) getSystemService(ALARM_SERVICE);
        alarm.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 1000, restartIntent);
        super.onTaskRemoved(rootIntent);
    }
    ```
    
    This schedules the service to restart almost immediately. This can work on some devices, but **may not work on others** (especially if the user also dismisses the notification or if the OEM blocks such behavior as part of “extreme” optimizations). Use with caution – it’s somewhat against the spirit of user explicitly closing the app. Always test on target devices.
    

In summary, harden your app with the right manifest declarations and code patterns: persistent services, correct permissions, auto-start on boot, companion device privileges if available, and robust reconnection logic. These will ensure your app can _survive_ in the background and recover from interruptions.

## 7. Monitoring and Recovery from Background Termination

Even with all precautions, you should assume your app **might** get terminated and design for graceful recovery. “Termination” could be due to the OS reclaiming resources or the user explicitly closing the app. Here’s how to monitor and bounce back:

- **Connection Monitoring:** Use Bluetooth APIs to detect connection loss. For BLE, `BluetoothGattCallback.onConnectionStateChange` will fire if the GATT connection drops (with a status). For classic Bluetooth (RFCOMM/SPP), you’d get an `IOException` on your socket read/write or an `ACTION_ACL_DISCONNECTED` broadcast. Make sure your service holds a reference to the Bluetooth device and connection, and if any disconnection is detected, **immediately schedule a reconnection attempt**. This could be an exponential backoff retry (to avoid battery drain if the device truly is away). If the app was killed entirely, you rely on the service restart (START_STICKY or Alarm) to then perform the reconnection in `onStartCommand`. For BLE, if you had used `autoConnect=true` on the initial `connectGatt`, the system may help by reconnecting in the background, but you still need the service alive to receive the callback.
    
- **Service Restart Logic:** We discussed using `START_STICKY` so that the OS revives the service after a kill. When the service comes back, check a persistent state (e.g., stored device address in `SharedPreferences` or a static variable that survived) to know which device to reconnect to, and then initiate the connection. Log or notify when a restart happens, so you know (via debugging or analytics) that a restart occurred. If you find your service restarting too often (say, the OS is killing it frequently), consider that a red flag – maybe you need to reduce resource usage or there’s an incompatibility with an OEM’s policies.
    
- **Foreground Notification Actions:** You can add an action in your persistent notification like “Reconnect” or “Check Status” which, when tapped, triggers a check in your service. This is a way for the user to manually kick the service if they suspect it’s not responding (maybe the device got disconnected while the app was in background). Also, in the notification, you can display the current status (e.g., “Connected” or “Disconnected – retrying…”). This keeps the user informed and engaged, possibly preventing them from force-killing the app out of frustration.
    
- **External Watchdog (if appropriate):** In some advanced cases, developers use a secondary mechanism to ensure the app is running. For example, scheduling a **JobService** every X hours to simply verify the service is running, and if not, start it. Or using **WorkManager** with `ExistingWorkPolicy.KEEP` to ensure at most one job runs – e.g., enqueue a unique work that runs daily to check “is my BluetoothService active; if not, start it.” Because WorkManager persists, it can run even after a reboot or app update. This is not real-time, but adds resilience for long-term operation.
    
- **Logging & Crash Recovery:** If the app crashed (perhaps due to a rare bug), using a separate process for the service means the service might survive it. If not, consider using a crash handler that writes to a log or sends out an error report on next launch, so you can fix issues that might be causing unexpected terminations. If you catch an exception in the service, try to handle it without letting the service die. For example, a Bluetooth exception when sending data can be caught and you can attempt a reconnect rather than letting it propagate and crash the service thread.
    
- **User Education:** Often, the user might inadvertently cause app termination by swiping it away or enabling a battery saver mode. Provide guidance in-app (maybe a FAQ or on-boarding tips) about steps to take if they want the app to run continuously. For instance: “To ensure continuous operation, please do not close the app from the recent list and consider enabling ‘Allow to run in background’ in your phone’s settings.” A small in-app reminder can prevent users from unknowingly shutting down the very service they want to keep.
    
- **Testing on Different OEMs:** Actively test your app’s background persistence on several brands (Google Pixel/AOSP, Samsung, Xiaomi, OnePlus, etc.). You might find that on some devices, after X minutes in background, the Bluetooth connection dies – then you know that device likely has an aggressive policy and you need to prompt the user with specific instructions (like enabling an autostart or removing battery limitations for your app).
    

**Recovery Example:** Suppose your BLE device sends vital data periodically. Your app is whitelisted and in a foreground service, so ideally it never gets killed. But the user accidentally swipes the notification or “closes all apps.” Your service’s `onTaskRemoved` schedules a restart in 1 second. On some devices, it restarts and reconnects – user might barely notice a hiccup. On others (e.g., Xiaomi), the OS might block that restart. Your app is now off. However, your app had registered a `PendingIntent` scan or perhaps the device itself comes back in range triggering a Bluetooth broadcast; those events wake your app again. If none of that happens, the user may notice the device isn’t updating. They open the app – your `MainActivity` could detect no service running and immediately start it (and auto-reconnect). The goal is to have multiple avenues to restore the connection so that downtime is minimal.

## 8. Device- and Manufacturer-Specific Quirks

Perhaps the biggest challenge is that not all Android devices honor the platform’s “rules” in the same way. Many manufacturers have added their own aggressive battery management techniques which can kill apps (even foreground services, in some cases) or ignore the official whitelist. Here are some known quirks and how to handle them:

- **Samsung (One UI):** Samsung devices, especially on Android 11 and above, have a feature called **“Put unused apps to sleep”** which is on by default. This can put your app into a sleep state if the user hasn’t launched it in a while, _even if you requested to ignore optimizations_. As of Android 11, Samsung will prevent background work unless the app is excluded from _both_ Android’s and Samsung’s optimization lists ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=Android%2011)). Advise users to go to **Settings > Battery and Device Care > Battery > Background usage limits**, and add your app to the “Never sleeping apps” list. Additionally, Samsung has a setting to **disable** Android’s Doze per app (on Android 10 it was under Special Access > Optimize Battery Usage). On Android 13, the interface changed and some options like “Optimize battery usage” moved, but generally ensuring the app isn’t restricted under Device Care is key ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=The%20settings%20are%20mostly%20the,below%2C%20with%20a%20few%20changes)) ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=Lists%20of%20Sleeping%20apps%2C%20Unused,sleeping%20apps%2C%20Never%20sleeping%20apps)). Samsung also introduced a quirk in Android 11: apps **cannot hold wake locks in foreground services** by default on Samsung firmware ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=standard%20app%20killing%2C%20in%20Android,See%20details%20here%20and)), which broke some apps that relied on constant wake locks. For a Bluetooth app, this means you should rely on the connection itself and the foreground service priority, and not try to hold a CPU wake lock forever on Samsung devices (the system will ignore it). In summary, instruct Samsung users to check **Device Care** settings and mark the app as never sleeping.
    
- **Xiaomi (MIUI):** Xiaomi MIUI is notorious for aggressive killing of background apps. By default, background processing “does not work right” on MIUI and apps will **break unless the user changes settings** ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=Traditionally%2C%20Xiaomi%20and%20their%20Android,apps%20using%20them%20will%20break)). Key steps for Xiaomi users:
    
    - Enable **Auto-start** for your app (MIUI often prevents apps from auto launching on boot or after being closed). This is found under the Security app or Settings > Apps > your app > Autostart ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=Autostart)). Without this, even if you try to restart your service, MIUI might not allow it to start in background.
    - Disable battery restrictions: On MIUI 11+ this is usually under **Settings > Battery & Performance > Choose apps > [Your App] > No restrictions** ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=1,to%20Off)). Or via Security app > Battery > App Battery Saver > set your app to “No restrictions” ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=App%20battery%20saver)). This essentially is the MIUI-specific whitelist.
    - MIUI has a feature called **“Lock Apps”** (or app pinning) in the Recent Apps screen. If the user locks the app, it won’t be swept away when they clear memory ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=App%20pinning%20%2F%20App%20locking)). Encourage users to lock the app in recents for extra safety.
    - **MIUI Optimizations:** In Developer Options, there’s a toggle for MIUI Optimizations which, when turned off, makes MIUI behave more like stock Android. This is more of an advanced tweak (and not available on all MIUI versions easily), but some power users do this to improve background behavior ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=most%20troubled%20group%20on%20the,apps%20using%20them%20will%20break)) ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=On%20some%20XiaoMi%20phones%2C%20several,these%20secret%20options%20and%20menus)).
    
    In short, Xiaomi users should whitelist the app in **Auto-start and Battery Saver** settings, and optionally lock it in recents. Otherwise, MIUI’s system task killer will likely terminate your service after a short time, regardless of foreground status.
    
- **OnePlus (OxygenOS / ColorOS):** OnePlus historically had **Deep Optimization** that aggressively killed apps. On OnePlus 5/6 generation, it was observed that even worse than Xiaomi/Huawei, the apps required special steps and these settings could reset on OS updates ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=When%20releasing%20their%201%2B5%20and,settings%20on%20a%20regular%20basis)). The guidance for OnePlus:
    
    - Turn off **Battery Optimization** for the app in Settings > Apps > Special Access > Battery Optimization (set to “Don’t optimize”). However, OnePlus has a bug/behavior where it may silently revert this setting back to optimize later ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=severe%20background%20limits%20on%20the,settings%20on%20a%20regular%20basis)) ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=,the%20solution%20above%20or%20here)).
    - **Lock the app in Recent Apps** (similar to Xiaomi). On OnePlus, pull up recents, tap the app card menu and lock it (you’ll see a padlock icon) ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=App%20locking)). This prevents it from being killed and also seems to stop the battery optimization setting from reverting ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=,the%20solution%20above%20or%20here)).
    - Disable any “Auto-launch” or “Advanced Optimization” features in OnePlus’s settings that could affect background apps ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=App%20Auto)).
    - Some OnePlus models have a toggle in Developer Options for “Disable Doze” which can help if turned off for older models ([Oneplus | Don’t kill my app!](https://dontkillmyapp.com/oneplus#:~:text=,options%20in%201%2B3%20and%20earlier)).
    
    Because OnePlus now shares a lot with Oppo’s ColorOS (in newer models), also ensure **App Auto-Launch** is allowed for your app in those settings.
    
- **Huawei (EMUI):** Huawei’s EMUI is extremely aggressive. It includes a service called **PowerGenie** (on EMUI 9+) that kills all apps not whitelisted by Huawei itself, with _no user setting to turn it off_ ([Huawei | Don’t kill my app!](https://dontkillmyapp.com/huawei#:~:text=UPDATE%3A%20On%20some%20phones%20with,while%20on%20others%20it%20isn%27t)) ([Huawei | Don’t kill my app!](https://dontkillmyapp.com/huawei#:~:text=There%20are%20no%20APIs%20and,working%20in%20background%20will%20break)). On some versions, even whitelisted apps or those set to “Manual manage” get killed after ~60 minutes in background ([Huawei | Don’t kill my app!](https://dontkillmyapp.com/huawei#:~:text=background%20will%20break)). Suggestions for Huawei:
    
    - In **Settings > Battery > App Launch**, find your app and choose “Manage manually,” then enable auto-launch, secondary launch, and background running ([Huawei | Don’t kill my app!](https://dontkillmyapp.com/huawei#:~:text=App%20Launch%20on%20some%20EMUI,P20%20Lite%2C%20Huawei%20Mate%2010%E2%80%A6)). This is the official way to whitelist on newer EMUI – it should exclude the app from Huawei’s EMUI idle kills.
    - Disable **Smart Tune-up** in the Phone Manager app if present ([Huawei | Don’t kill my app!](https://dontkillmyapp.com/huawei#:~:text=Smart%20Tune)).
    - If PowerGenie is on the device and still killing your app, the nuclear option some users take is to remove it via ADB (`adb shell pm uninstall -k --user 0 com.huawei.powergenie`). This obviously isn’t something your app can do (nor should you instruct average users to), but tech-savvy users may find guides to do this. With PowerGenie gone, background behavior improves.
    - Huawei also has a “Protected apps” or “Stay connected while asleep” setting on older EMUI (5 and below) – ensure users add the app there if their device has that menu.
    
    With Huawei, you may need to be very explicit in guiding users, perhaps via a support article, because it can be frustrating – the app might still get killed due to things outside your control.
    
- **OPPO / Vivo:** These brands (and Realme, etc. which have similar firmware) also have aggressive app killing. They often require the user to allow the app to run in background in a custom settings menu. For OPPO, instruct users to: go to Settings > Battery > Battery Optimization, find your app and select “Don’t optimize.” Also Settings > Apps Management > Auto-start, and enable your app. Vivo has “High background power consumption” toggle that needs to be enabled for your app, otherwise it will terminate it after a while. **Realme** (which is OPPO-based) similarly needs lock in recents and “Allow background run” toggled.
    
- **Others:** Smaller brands and some Android One devices might follow stock rules more closely (Android One Xiaomi phones, Nokia, Motorola, etc., generally behave like stock or have mild additions). Sony and HTC historically were close to stock (with maybe a stamina mode that user can disable per app). Asus has a “Power Master” app that could kill background apps, so users should add exception there. Each OEM might have a unique name for these settings (“Battery Saver”, “Smart Background”, etc.). A great resource is **dontkillmyapp.com**, which lists many manufacturers and what steps to take. It might be useful to share that resource with power users for detailed instructions.
    

**Developer Actions for OEM Quirks:** Unfortunately, as a developer you cannot programmatically override most of these OEM settings – you must rely on the user to follow instructions. What you _can_ do is detect some known devices and show in-app guidance. For example, you can check `Build.MANUFACTURER` and if it’s "Xiaomi", prompt the user: “Xiaomi’s MIUI may be preventing background operation. Please ensure [App Name] is allowed to auto-start and has no background restrictions. [Show me how]”. The “[Show me how]” could open a WebView or link to a help page (or even attempt to open the specific Settings screen if known – some OEMs have hidden Intents you could try, but they’re not officially documented). For OnePlus, you might alert them to lock the app in recents. For Samsung, instruct them about Device Care. By handling the top few manufacturers that cover a large user base, you’ll alleviate most background kill issues.

## 9. Common Pitfalls Causing Background Kills

Finally, let’s summarize some **common mistakes** that can lead to an app being killed in the background and how to avoid them:

- **Not using Foreground Service for long tasks:** Trying to keep a Bluetooth connection alive with a normal background service or an Activity alone is a mistake. Android will stop background services a few minutes after the app goes background (especially on Android 8+). Always promote to a foreground service with a notification for ongoing communication ([android - How to Bluetooth LE background connection? - Stack Overflow](https://stackoverflow.com/questions/77595114/how-to-bluetooth-le-background-connection#:~:text=Here%20I%20suggest%20please%20use,would%20be%20the%20great%20option)).
    
- **Starting a Service improperly on Oreo+:** If you call `startService()` when your app is in background (no foreground UI) on Android 8+, the system will throw an IllegalStateException and prevent the service start. This can lead to missed connections or tasks. The correct way is to use `startForegroundService()`, then call `startForeground()` with a notification _within 5 seconds_. Failing to call `startForeground()` promptly will result in the service being terminated by the system. Make sure this sequence is correct to avoid the “Service did not start in foreground” kill.
    
- **Forgetting to obtain user permissions:** If your app is not granted necessary permissions (Bluetooth, location for BLE, etc.), it might silently fail to perform tasks in background, which might look like it’s being killed. For instance, on Android 11, if you try to scan for BLE devices in background without ACCESS_BACKGROUND_LOCATION, the scan will simply not return results after a short time. Always handle permission prompts gracefully and consider directing the user to settings if they deny but want the app to function fully.
    
- **No user-visible notification or feedback:** If you run a foreground service but hide or remove the notification (some devs try to do this to make it “invisible”), the system might consider that as not truly foreground (removing the notification of a foreground service is actually not allowed without stopping the service). Even if you trick it, users or OEM software might kill the app because they don’t see it doing anything. Always keep the notification; it’s both a requirement and a courtesy to the user.
    
- **Overloading the background with heavy work:** If your service does too much in background (CPU or battery intensive operations) for a long time, the system’s **Watchdog or Performance monitors** can flag it. For example, doing continuous BLE scanning and processing large amounts of data without yield can be expensive. This might not directly “kill” the app, but it could trigger the OS to classify it as a high battery user, which on some devices (Samsung’s Battery Guardian, etc.）will then throttle or stop it ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=,the%20system%20decides)). Mitigate this by offloading heavy computations to when the device is charging or the app is foreground, if possible, or at least use efficient algorithms and sleep intervals when appropriate.
    
- **Not handling connectivity gracefully:** If the Bluetooth connection drops and your app spins trying to reconnect in a tight loop, you’ll drain battery and possibly cause the system to intervene. Use backoff strategies for reconnection attempts and pause retries after a certain number of failures to give the system (and the user) a break. You might resume later via a scheduled job or when the user opens the app.
    
- **Ignoring App Standby/Doze completely:** Some developers assume “if I use a foreground service, I’m immortal.” While you greatly increase your chances, remember Doze still affects network and CPU. For instance, if your BLE device expects a response every 5 minutes and the phone goes into deep Doze for 20 minutes, you could lose data. If you didn’t account for this, it might seem like the app failed. Always test under idle conditions. If something fails only during long idle times, suspect Doze and adjust (perhaps by asking for the whitelist or changing the device’s strategy).
    
- **Not educating the user:** As mentioned, if users don’t understand the need for the app to run in background, they might manually close it or deny the battery optimization exemption. That’s not a code pitfall per se, but it’s a design pitfall. Provide proper onboarding if persistent background operation is a feature. For example, show a dialog: “For the app to stay connected to your Bluetooth device, it needs to run in the background. We’ll show a notification while connected. Please don’t force close the app or restrict its battery usage if you want continuous monitoring.”
    
- **Failing to test on real devices:** Relying purely on emulator or one device can blindside you. The emulator might not simulate OEM behaviors. Always test on at least one device with known aggressive policy (like a Xiaomi or Samsung) to see how your app fares. There are community-shared tools and benchmarks (e.g., DontKillMyApp’s benchmark app) that you can use to test if your app survives certain conditions.
    

By avoiding these pitfalls and following the strategies above, you can significantly improve your app’s reliability. Users will appreciate a stable connection to their Bluetooth device across a variety of phones and Android versions, and you’ll receive fewer complaints about the app “not working in background” or “disconnecting overnight.”

## 10. Conclusion

Supporting robust Bluetooth communication in the background on Android (especially modern Android) is challenging but feasible with the right approach. Always start with the foundation: a properly implemented **foreground service** that keeps your app alive and visible to the system ([service - What is the best way to maintain a Bluetooth connection after app is killed in Android? - Stack Overflow](https://stackoverflow.com/questions/43267520/what-is-the-best-way-to-maintain-a-bluetooth-connection-after-app-is-killed-in-a#:~:text=First%20of%20all%20I%20suggest,using%20a%20foreground%20service)). Layer on adaptations for **Doze and Standby** – know when to use the battery optimization whitelist ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=,than%20some%20Google%20system%20apps)) and how to schedule background work within the system’s guidelines. Use **WorkManager/JobScheduler** to handle periodic or deferred tasks instead of manual background loops, and handle reconnections and restarts gracefully. Above all, **respect the user’s battery and attention**: run only what you need to, and be transparent (via notifications or settings) about what your app is doing.

Remain vigilant about **manufacturer-specific behaviors**: they can and will interfere, so provide users with information to adjust their settings (and cite examples: Samsung’s device care, Xiaomi’s autostart, etc. as covered). Keep an eye on updates from these OEMs as well, since policies can change with OS updates.

By following these best practices and strategies, you maximize the chances that your app remains running and your Bluetooth device stays connected across a wide range of Android devices and versions. This results in a much better experience for your users who depend on continuous Bluetooth data, and saves you from many headaches caused by mysterious background kills.

**References:**

- Android Developers Documentation – _“Communicate with Devices in the Background”_ ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=REQUEST_COMPANION_RUN_IN_BACKGROUND%20%20permission%20and%20the,with%20the%20connectedDevice%20foreground%20type)) ([Communicate in the background  |  Connectivity  |  Android Developers](https://developer.android.com/develop/connectivity/bluetooth/ble/background#:~:text=To%20listen%20to%20peripheral%20notifications,also%20use%20a%20foreground%20service))
- Android Developers Documentation – _“Optimize for Doze and App Standby”_ ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=,Fi%20scans)) ([Optimize for Doze and App Standby  |  App quality  |  Android Developers](https://developer.android.com/training/monitoring-device-state/doze-standby#:~:text=system%20exits%20Doze%20shortly%20before,tasks%20don%27t%20run))
- Stack Overflow – Advice on using Foreground Service for Bluetooth stability ([service - What is the best way to maintain a Bluetooth connection after app is killed in Android? - Stack Overflow](https://stackoverflow.com/questions/43267520/what-is-the-best-way-to-maintain-a-bluetooth-connection-after-app-is-killed-in-a#:~:text=First%20of%20all%20I%20suggest,using%20a%20foreground%20service)) ([android - How to Bluetooth LE background connection? - Stack Overflow](https://stackoverflow.com/questions/77595114/how-to-bluetooth-le-background-connection#:~:text=Here%20I%20suggest%20please%20use,would%20be%20the%20great%20option))
- _Don’t Kill My App!_ (industry community) – Manufacturer-specific battery optimization behaviors (Samsung, Xiaomi, OnePlus, Huawei) ([Samsung | Don’t kill my app!](https://dontkillmyapp.com/samsung#:~:text=Android%2011)) ([Xiaomi | Don’t kill my app!](https://dontkillmyapp.com/xiaomi#:~:text=Traditionally%2C%20Xiaomi%20and%20their%20Android,apps%20using%20them%20will%20break))
- Zebra Dev Blog – _“Keeping Your Application Running when the device sleeps”_ (Doze and whitelisting explanation) ([Keeping your Android application running when the device wants to sleep (Updated for Android Pie) | Developer Portal](https://developer.zebra.com/blog/keeping-your-android-application-running-when-device-wants-sleep-updated-android-pie#:~:text=automatically%20released%20when%20the%20device,see%20later))